%\extrapart{Bibliography and references}

% My reference for proper reference format is:
%    Mary-Claire van Leunen.
%    {\em A Handbook for Scholars.}
%    Knopf, 1978.
% I think the references list would look better in ``open'' format,
% i.e. with the three blocks for each entry appearing on separate
% lines.  I used the compressed format for SIGPLAN in the interest of
% space.  In open format, when a block runs over one line,
% continuation lines should be indented; this could probably be done
% using some flavor of latex list environment.  Maybe the right thing
% to do in the long run would be to convert to Bibtex, which probably
% does the right thing, since it was implemented by one of van
% Leunen's colleagues at DEC SRC.
%  -- Jonathan

% I tried to follow Jonathan's format, insofar as I understood it.
% I tried to order entries lexicographically by authors (with singly
% authored papers first), then by date.
% In some cases I replaced a technical report or conference paper
% by a subsequent journal article, but I think there are several
% more such replacements that ought to be made.
%  -- Will, 1991.

% This is just a personal remark on your question on the RRRS:
% The language CUCH (Curry-Church) was implemented by 1964 and 
% is a practical version of the lambda-calculus (call-by-name).
% One reference you may find in Formal Language Description Languages
% for Computer Programming T.~B.~Steele, 1965 (or so).
%  -- Matthias Felleisen


\begin{thebibliography}{999}

\bibitem{Abelson88} %new
Harold Abelson and Gerald Jay Sussman.
Lisp: a langauge for stratified design.
{\em BYTE} 13(2):207--218, February 1988.

\bibitem{SICP}
Harold Abelson and Gerald Jay Sussman with Julie Sussman.
{\em Structure and Interpretation of Computer Programs.}
MIT Press, Cambridge, 1985.

\bibitem{Adams88} %new
Norman Adams and Jonathan Rees.
Object-oriented programming in Scheme.
In {\em Proceedings of the 1988 Conference on Lisp
  and Functional Programming}, pages 277--288, August 1988.

\bibitem{Bartley86}
David H.~Bartley and John C.~Jensen.
The implementation of PC Scheme.
In {\em Proceedings of the 1986 ACM Conference on Lisp
  and Functional Programming}, pages 86--93.

\bibitem{Scheme81}
John Batali, Edmund Goodhue, Chris Hanson, Howie Shrobe, Richard
  M.~Stallman, and Gerald Jay Sussman.
The Scheme-81 architecture---system and chip.
In {\em Proceedings, Conference on Advanced Research in VLSI},
  pages 69--77.
Paul Penfield, Jr., editor.
Artech House, 610 Washington Street, Dedham MA, 1982.

\bibitem{Bawden88} %new
Alan Bawden and Jonathan Rees.
Syntactic closures.
In {\em Proceedings of the 1988 ACM Symposium on Lisp and
  Functional Programming}, pages 86--95.

\todo{Church??}

\bibitem{Clinger84}
William Clinger.
The Scheme 311 compiler: an exercise in denotational semantics.
In {\em Conference Record of the 1984 ACM Symposium on Lisp and
  Functional Programming}, pages 356--364.

\bibitem{RRRS}
William Clinger, editor.
The revised revised report on Scheme, or an uncommon Lisp.
MIT Artificial Intelligence Memo 848, August 1985.
Also published as Computer Science Department Technical Report 174,
  Indiana University, June 1985.

\bibitem{Clinger88} %new
William Clinger.
Semantics of Scheme.
{\em BYTE} 13(2):221--227, February 1988.

\bibitem{howtoread} %new
William Clinger.
How to read floating point numbers accurately.
In {\em Proceedings of the ACM SIGPLAN '90 Conference
  on Programming Language Design and Implementation}, pages 92--101.
Proceedings published as {\em SIGPLAN Notices} 25(6), June 1990.

\bibitem{Clinger85} %new
William Clinger, Daniel P.~Friedman, and Mitchell Wand.
A scheme for a higher-level semantic algebra.
In {\em Algebraic Methods in Semantics}, pages 237--250.
J. Reynolds, M. Nivat, editor.
Cambridge University Press, 1985.

\bibitem{Clinger88b} %new
William Clinger, Anne Hartheimer, and Eric Ost.
Implementation strategies for continuations.
In {\em Proceedings of the 1988 ACM Conference on Lisp and Functional
  Programming}, pages 124--131.

\bibitem{macrosthatwork} %new
William Clinger and Jonathan Rees.
Macros that work.
In {\em Proceedings of the 1991 ACM Conference on Principles of
  Programming Languages}, pages~155--162.

\bibitem{Curtis90} %new
Pavel Curtis and James Rauen.
A module system for Scheme.
In {\em Proceedings of the 1990 ACM Conference on Lisp and
  Functional Programming}, June 1990.
\todo{pages?}

\bibitem{Dybvig87} %new
R.~Kent Dybvig.
{\em The Scheme Programming Language.}
Prentice-Hall, 1987.

% \bibitem{Dybvig86}
% R.~Kent Dybvig, Daniel P.~Friedman, and Christopher T.~Haynes.
% Expansion-passing style: Beyond conventional macros.
% In {\em Proceedings of the 1986 ACM Conference on Lisp and
%   Functional Programming}, pages 143--150.

\bibitem{Dybvig86} %new; replaces the above
R.~Kent Dybvig and Daniel P. Friedman and Christopher T. Haynes.
Expansion-passing style: a general macro mechanism.
{\em Lisp and Symbolic Computation} 1(1):53--76, June 1988.

\bibitem{Dybvig88} %new
R.~Kent Dybvig and Robert Hieb.
A variable-arity procedural interface.
In {\em Proceedings of the 1988 ACM Symposium on Lisp and
  Functional Programming}, pages 106--115.

\bibitem{Dybvig88} %new
R.~Kent Dybvig and Robert Hieb.
Engines from continuations.
{\em Journal of Computer Languages} 14(2), pages~109--123,
1989.

\bibitem{Dybvig88} %new
R.~Kent Dybvig and Robert Hieb.
Continuations and concurrency.
In {\em Proceedings of the Second ACM SIGPLAN Notices
  Symposium on Principles and Practice of Parallel Programming},
pages~128--136, March 1990.

% technical report:

\bibitem{Eisenberg85}
Michael A.~Eisenberg.
Bochser: an integrated Scheme programming system.
MIT Laboratory for Computer Science Technical Report 349,
  October 1985.

\bibitem{Eisenberg88} %new
Michael Eisenberg.
Harold Abelson, editor.
{\em Programming In Scheme.}
Scientific Press, Redwood City, California, 1988.

\bibitem{Eisenberg90} %new
Michael Eisenberg, with William Clinger and Anne Hartheimer.
Harold Abelson, editor.
{\em Programming In MacScheme.}
Scientific Press, San Francisco, 1990.

\bibitem{Feeley86}
Marc Feeley.
Deux approches \`{a} l'implantation du language Scheme.
M.Sc.~thesis, D\'{e}partement d'Informatique et de Recherche
  Op\'{e}rationelle, University of Montreal, May 1986.

\bibitem{Feeley87} %new
Marc Feeley and Guy LaPalme.
Using closures for code generation.
{\em Journal of Computer Languages} 12(1):47--66, 1987.

\bibitem{Feeley90} %new
Marc Feeley and James Miller.
A parallel virtual machine for efficient Scheme compilation.
In {\em Proceedings of the 1990 ACM Conference on Lisp and
  Functional Programming}, June 1990.
\todo{pages?}

\bibitem{Felleisen87b} %new
Matthias Felleisen.
Reflections on Landin's J-Operator: a partly historical note.
{\em Journal of Computer Languages} 12(3/4):197--207, 1987.

\bibitem{Felleisen86b} %new
Matthias Felleisen and Daniel P. Friedman.
Control operators, the SECD-machine, and the lambda-calculus.
In {\em 3rd Working Conference on the Formal Description of
   Programming Concepts}, pages 193--219, August 1986.

\bibitem{Felleisen86c} %new
Matthias Felleisen and Daniel P.~Friedman.
A closer look at export and import statements.
{\em Journal of Computer Languages} 11(1):29--37, 1986.

\bibitem{Felleisen87} %new
Matthias Felleisen and Daniel P. Friedman.
A calculus for assignments in higher-order languages.
In {\em Conference Record of the 14th Annual ACM Symposium
  on Principles of Programming Languages}, pages 314--345, January 1987.

\bibitem{Felleisen87d} %new
Matthias Felleisen and Daniel P.~Friedman.
A reduction semantics for imperative higher-order languages.
In {\em Lecture Notes in Computer Science}, 
{\em Parallel Architectures and Languages Europe} 259:206--223, 1987.
De Bakker, Nijman and Treleaven, editors.
Springer-Verlag, Berlin.

\bibitem{Felleisen86}
Matthias Felleisen, Daniel P.~Friedman, Eugene Kohlbecker, and Bruce Duba.
Reasoning with continuations.
In {\em Proceedings of the Symposium on Logic in Computer Science},
  pages 131--141.
IEEE Computer Society Press, Washington DC, 1986.

% Does [Felleisen87c] replace [Felleisen86] above?

\bibitem{Felleisen87c} %new
Matthias Felleisen, Daniel P.~Friedman, Eugene E.~Kohlbecker, and Bruce Duba.
A syntactic theory of sequential control.
{\em Theoretical Computer Science} \todo{5(2)?}52:205--237, 1987.

\bibitem{Felleisen88} %new
Matthias Felleisen, Mitchell Wand, Daniel P.~Friedman, and Bruce Duba.
Abstract continuations: a mathematical semantics for
  handling functional jumps.
In {\em Proceedings of the 1988 ACM Symposium on Lisp and
  Functional Programming},
  \todo{pages} July 1988.

% technical report

\bibitem{Scheme311}
Carol Fessenden, William Clinger, Daniel P.~Friedman, and Christopher Haynes.
Scheme 311 version 4 reference manual.
Indiana University Computer Science Technical Report 137, February 1983.
Superseded by~\cite{Scheme84}.

\bibitem{Franco90} %new
John Franco and Daniel P.~Friedman.
Towards a facility for lexically scoped, dynamic mutual recursion
  in Scheme.
{\em Journal of Computer Languages} 15(1):55--64, 1990.

\bibitem{Lisper}
Daniel P.~Friedman and Matthias Felleisen.
{\em The Little LISPer.}
Science Research Associates, second edition 1986.

\bibitem{littlelisper}
Daniel P.~Friedman and Matthias Felleisen.
{\em The Little LISPer.}
MIT Press, 1987.

\bibitem{Friedman85}
Daniel P.~Friedman and Christopher T.~Haynes.
Constraining control.
In {\em Proceedings of the Twelfth Annual Symposium on Principles of
  Programming Languages}, pages 245--254.
ACM, January 1985.

\bibitem{Friedman84}
Daniel P.~Friedman, Christopher T.~Haynes, and Eugene Kohlbecker.
Programming with continuations.
In {\em Program Transformation and Programming Environments,\/}
  pages 263--274.
P.~Pepper, editor.
Springer-Verlag, 1984.

\bibitem{Scheme84}
D.~Friedman, C.~Haynes, E.~Kohlbecker, and M.~Wand.
Scheme 84 interim reference manual.
Indiana University Computer Science Technical Report 153, January 1985.

\bibitem{Friedman84b} %new
Daniel P. Friedman and Mitchell Wand.
Reification: reflection without metaphysics.
In {\em Conference Record of the 1984 ACM Symposium on Lisp
  and Functional Programming}, pages 348--355.

\bibitem{Haynes86}
Christopher T.~Haynes.
Logic continuations. 
In {\em Proceedings of the Third International Conference on
  Logic Programming,\/} pages 671--685.
Springer-Verlag, July 1986.
% and to appear in {\it The Journal of Logic Programming.}
\todo{find the journal reference}

\bibitem{Engines}
Christopher T.~Haynes and Daniel P.~Friedman.
Engines build process abstractions.
In {\em Conference Record of the 1984 ACM Symposium on Lisp and
  Functional Programming,\/} pages 18--24.

% Does this replace [Engines] above?

\bibitem{Haynes87b} %new
Christopher T.~Haynes and Daniel P.~Friedman.
Abstracting timed preemption with engines.
{\em Journal of Computer Languages} 12(2):109--121, 1987.

\bibitem{Haynes87a} %new
Christopher T.~Haynes and Daniel P.~Friedman.
Embedding continuations in procedural objects.
{\em ACM Transactions on Programming Languages and Systems} 9(4):582--598,
  October 1987.

% \bibitem{Haynes84}
% Christopher T.~Haynes, Daniel P.~Friedman, and Mitchell Wand.
% Continuations and coroutines.
% In {\em Conference Record of the 1984 ACM Symposium on Lisp and
%   Functional Programming,} pages 293--298.

% I assume the one below replaces the one above.

\bibitem{Haynes86} %new
Christopher T.~Haynes and Daniel P.~Friedman and Mitchell Wand.
Obtaining coroutines with continuations.
{\em Journal of Computer Languages} 11(3/4):143--153, 1986.

\bibitem{Henderson82}
Peter Henderson.
Functional geometry.
In {\em Conference Record of the 1982 ACM Symposium on Lisp and
  Functional Programming}, pages 179--187.

\bibitem{Dybvig88} %new
Robert Hieb, R.~Kent Dybvig, and Carl Bruggeman.
Representing control in the presence of first-class continuations.
In {\em Proceedings of the ACM SIGPLAN '90 Conference on Programming
  Language Design and Implementation},
pages~66--77, June 1990.
Proceedings published as {\em SIGPLAN Notices} 25(6), June 1990.

\bibitem{IEEE}
{\em IEEE Standard 754-1985.  IEEE Standard for Binary Floating-Point
Arithmetic.}  IEEE, New York, 1985.

\bibitem{IEEEScheme}
{\em IEEE Standard 1178-1990.  IEEE Standard for the Scheme
  Programming Language.}  IEEE, New York, 1991.

\bibitem{Kohlbecker86}
Eugene Edmund Kohlbecker~Jr.
{\em Syntactic Extensions in the Programming Language Lisp.}
PhD thesis, Indiana University, August 1986.

\bibitem{hygienic}
Eugene E.~Kohlbecker, Daniel P.~Friedman, Matthias Felleisen, and Bruce Duba.
Hygienic macro expansion.
In {\em Proceedings of the 1986 ACM Conference on Lisp
  and Functional Programming}, pages 151--161.

\bibitem{Kranz86}
David Kranz, Richard Kelsey, Jonathan Rees, Paul Hudak, James Philbin,
  and Norman Adams.
Orbit: An optimizing compiler for Scheme.
In {\em Proceedings of the SIGPLAN '86 Symposium on Compiler
  Construction}, pages 219--233.
ACM, June 1986.
Proceedings published as {\em SIGPLAN Notices} 21(7), July 1986.

\bibitem{Kranz88}
David Kranz.
{\em Orbit: An optimizing compiler for Scheme.}
PhD thesis, Yale University, 1988.

\bibitem{Landin65}
Peter Landin.
A correspondence between Algol 60 and Church's lambda notation: Part I.
{\em Communications of the ACM} 8(2):89--101, February 1965.

\bibitem{McDermott80}
Drew McDermott.
An efficient environment allocation scheme in an interpreter for a
  lexically-scoped lisp.
In {\em Conference Record of the 1980 Lisp Conference,} pages
  154--162.
% The Lisp Conference, P.O.~Box 487, Redwood Estates CA,
%  1980.
Proceedings reprinted by ACM.

\bibitem{MITScheme}
MIT Department of Electrical Engineering and Computer Science.
Scheme manual, seventh edition.
September 1984.

\bibitem{Muchnick80}
Steven S.~Muchnick and Uwe F.~Pleban.
A semantic comparison of Lisp and Scheme.
In {\em Conference Record of the 1980 Lisp Conference}, pages 56--64.
% The Lisp Conference, 1980.
Proceedings reprinted by ACM.

\bibitem{Naur63}
Peter Naur et al.
Revised report on the algorithmic language Algol 60.
{\em Communications of the ACM} 6(1):1--17, January 1963.

\bibitem{Penfield81}
Paul Penfield, Jr.
Principal values and branch cuts in complex APL.
In {\em APL '81 Conference Proceedings,} pages 248--256.
ACM SIGAPL, San Francisco, September 1981.
Proceedings published as {\em APL Quote Quad} 12(1), ACM, September 1981.

% technical report

\bibitem{Pitman85}
Kent M.~Pitman.
Exceptional situations in Lisp.
MIT Artificial Intelligence Laboratory Working Paper 268, February 1985.

% technical report

\bibitem{Pitman83}
Kent M.~Pitman.
The revised MacLisp manual (Saturday evening edition).
MIT Laboratory for Computer Science Technical Report 295, May 1983.

\bibitem{Pitman80}
Kent M.~Pitman.
Special forms in Lisp.
In {\em Conference Record of the 1980 Lisp Conference}, pages 179--187.
% The Lisp Conference, 1980.
Proceedings reprinted by ACM.

\bibitem{Plebanthesis} %new
Uwe F. Pleban.
{\em A Denotational Approach to Flow Analysis and Optimization of Scheme,
A Dialect of Lisp.} PhD thesis, University of Kansas, 1980.

\bibitem{Rees89}
Jonathan A.~Rees.
{\em Modular Macros}.
M.S.~thesis, MIT, May 1989.

\bibitem{Rees82}
Jonathan A.~Rees and Norman I.~Adams IV.
T: A dialect of Lisp or, lambda: The ultimate software tool.
In {\em Conference Record of the 1982 ACM Symposium on Lisp and
  Functional Programming}, pages 114--122.

\bibitem{Rees84}
Jonathan A.~Rees, Norman I.~Adams IV, and James R.~Meehan.
The T manual, fourth edition.
Yale University Computer Science Department, January 1984.

\bibitem{R3RS}
Jonathan Rees and William Clinger, editors.
The revised$^3$ report on the algorithmic language Scheme.
In {\em ACM SIGPLAN Notices} 21(12), pages~37--79, December 1986.

\bibitem{Reynolds72}
John Reynolds.
Definitional interpreters for higher order programming languages.
In {\em ACM Conference Proceedings}, pages 717--740.
ACM, \todo{month?}~1972.

\bibitem{Rozas84}
Guillermo J.~Rozas.
Liar, an Algol-like compiler for Scheme.
S.~B.~thesis, MIT Department of Electrical Engineering and Computer
  Science, January 1984.

\bibitem{schflow} %new
Olin Shivers.
Control flow analysis in Scheme.
{\em Proceedings of the SIGPLAN 1988 Conference on
  Programming Language Design and Implementation}, pages 164--174.
Proceedings published as {\em SIGPLAN Notices} 23(7), July 1988.

\bibitem{Sitaram90} %new
Dorai Sitaram and Matthias Felleisen.
Control delimiters and their hierarchies.
{\em Lisp and Symbolic Computation} 3(1):67--99, January 1990.

% technical report

\bibitem{Smith84}
Brian C.~Smith.
Reflection and semantics in a procedural language.
MIT Laboratory for Computer Science Technical Report 272, January 1982.

\bibitem{Springer89} %new
George Springer and Daniel P.~Friedman.
{\em Scheme and the Art of Programming.}
MIT Press and McGraw-Hill, 1989.

\bibitem{Srivastava85}
Amitabh Srivastava, Don Oxley, and Aditya Srivastava.
An(other) integration of logic and functional programming.
In {\em Proceedings of the Symposium on Logic Programming}, pages 254--260. 
IEEE, 1985.

% technical report

\bibitem{Stallman80}
Richard M.~Stallman.
Phantom stacks---if you look too hard, they aren't there.
MIT Artificial Intelligence Memo 556, July 1980.

% NOTE -- there should not be a comma between ``Steele'' and ``Jr.''

\bibitem{Declarative}
Guy Lewis Steele Jr.
Lambda, the ultimate declarative.
MIT Artificial Intelligence Memo 379, November 1976.

\bibitem{Debunking}
Guy Lewis Steele Jr.
Debunking the ``expensive procedure call'' myth, or procedure call
  implementations considered harmful, or lambda, the ultimate GOTO.
In {\em ACM Conference Proceedings}, pages 153--162.
ACM, 1977.

\bibitem{Macaroni}
Guy Lewis Steele Jr.
Macaroni is better than spaghetti.
In {\em Proceedings of the Symposium on Artificial Intelligence and
  Programming Languages}, pages 60--66.
These proceedings were published as a special joint issue of {\em
  SIGPLAN Notices} 12(8) and {\em SIGART Newsletter} 64, August 1977.

\bibitem{Rabbit}
Guy Lewis Steele Jr.
Rabbit: a compiler for Scheme.
MIT Artificial Intelligence Laboratory Technical Report 474, May 1978.

\bibitem{renamegoto} %new
Guy Lewis Steele Jr.
Compiler optimization based on viewing LAMBDA as RENAME + GOTO.
In {\em AI: An MIT Perspective.}
Patrick Henry Winston Richard Henry Brown, editor.
MIT Press, 1980.

\bibitem{CLoverview}
Guy Lewis Steele Jr.
An overview of Common Lisp.
In {\em Conference Record of the 1982 ACM Symposium on Lisp and
  Functional Programming}, pages 98--107.

\bibitem{CLtL}
Guy Lewis Steele Jr.
{\em Common Lisp: The Language.}
Digital Press, Burlington MA, 1984.

\bibitem{Imperative}
Guy Lewis Steele Jr.~and Gerald Jay Sussman.
Lambda, the ultimate imperative.
MIT Artificial Intelligence Memo 353, March 1976.

\bibitem{Scheme78}
Guy Lewis Steele Jr.~and Gerald Jay Sussman.
The revised report on Scheme, a dialect of Lisp.
MIT Artificial Intelligence Memo 452, January 1978.

\bibitem{TAOTI}
Guy Lewis Steele Jr.~and Gerald Jay Sussman.
The art of the interpreter, or the modularity complex (parts zero, one,
  and two).
MIT Artificial Intelligence Memo 453, May 1978.

\bibitem{DOALBP}
Guy Lewis Steele Jr.~and Gerald Jay Sussman.
Design of a Lisp-based processor.
{\em Communications of the ACM} 23(11):628--645, November 1980.

\bibitem{Dream}
Guy Lewis Steele Jr.~and Gerald Jay Sussman.
The dream of a lifetime: a lazy variable extent mechanism.
In {\em Conference Record of the 1980 Lisp Conference}, pages 163--172.
% The Lisp Conference, 1980.
Proceedings reprinted by ACM.

\bibitem{howtoprint}
Guy Lewis Steele Jr.~and Jon L White.
How to print floating point numbers accurately.
In {\em Proceedings of the ACM SIGPLAN '90 Conference
  on Programming Language Design and Implementation}, pages~112--126.
Proceedings published as {\em SIGPLAN Notices} 25(6), June 1990.

\bibitem{Sussman82}
Gerald Jay Sussman.
Lisp, programming and implementation.
In {\em Functional Programming and its Applications.}
Darlington, Henderson, Turner, editor.
Cambridge University Press, 1982.

\bibitem{Scheme75}
Gerald Jay Sussman and Guy Lewis Steele Jr.
Scheme: an interpreter for extended lambda calculus.
MIT Artificial Intelligence Memo 349, December 1975.

\bibitem{Scheme79}
Gerald Jay Sussman, Jack Holloway, Guy Lewis Steele Jr., and Alan Bell.
Scheme-79---Lisp on a chip.
{\em IEEE Computer} 14(7):10--21, July 1981.

\bibitem{Stoy77}
Joseph E.~Stoy.
{\em Denotational Semantics: The Scott-Strachey Approach to
  Programming Language Theory.}
MIT Press, Cambridge, 1977.

\bibitem{TI85}
Texas Instruments, Inc.
{\em TI Scheme Language Reference Manual.}
Preliminary version 1.0, November 1985.
\todo{get a more recent reference}

\bibitem{Vegdahl89}
Steven R.~Vegdahl and Uwe F.~Pleban.
The runtime environment for Screme, a Scheme implementation on the 88000.
In {\em Proceedings of the Third International Conference on Architectural
  Support for Programming Languages and Operating Systems},
  pages 172--182, April 1989.

\bibitem{Wand78}
Mitchell Wand.
Continuation-based program transformation strategies.
{\em Journal of the ACM} 27(1):174--180, 1978.

\bibitem{Wand80}
Mitchell Wand.
Continuation-based multiprocessing.
In {\em Conference Re\-cord of the 1980 Lisp Conference}, pages 19--28.
Proceedings available from ACM.

\bibitem{Wand86} %new
Mitchell Wand.
{\em Finding the source of type errors.}
In {\em Conference Record of the Thirteenth Annual Symposium on
  Principles of Programming Languages}, pages 38--43, 1986.
\todo{make sure this is relevant}

\bibitem{tower} %new
Mitchell Wand.
The mystery of the tower revealed: a non-reflective description of the reflective tower.
In {\em Proceedings of the 1986 ACM Symposium on LISP and Functional
  Programming}, pages 298--307, August 1986.

\bibitem{Wand78} %new
Mitchell Wand and Daniel P. Friedman.
Compiling lambda expressions using continuations and factorizations.
{\em Journal of Computer Languages} 3:241--263, 1978.

% This next one probably replaces [tower] above, but the above is
% probably more widely available.

\bibitem{Wand88} %new
Mitchell Wand and Daniel P.~Friedman.
The mystery of the tower revealed: a non-reflective description of the
  reflective tower.
In {\em Meta-Level Architectures and Reflection}, pages 111--134.
P. Maes and D. Nardi, editor.
Elsevier Sci. Publishers B.V. (North Holland), 1988.

\end{thebibliography}
